## 3부. 객체 지향  

### 8장. 참조 자료형에 대해서 더 자세히 알아봅시다.  

#### 1. 참조 자료형은 나머지 다에요.  
- new 없이도 객체를 생성할 수 있는 참조 자료형은 오직 `String` 뿐  

#### 2. 기본 생성자  
- 매개변수가 없는 기본 생성자는 `다른 생성자가 없을 경우` 기본으로 `컴파일`할 때 만들어진다.  
- 생성자가 없더라도 객체를 얻을 수 있는 클래스도 있다.  

#### 3. 생성자는 몇 개까지 만들 수 있을까?  
- DTO (Data Transfer Object) : 데이터를 다른 서버로 전달하는 것이 주 목적  
- VO (Value Object) : 데이터를 담아두기 위한 것이 목적  
- 어떻게 보면 DTO가 VO를 포함한다고 볼 수 있기 때문에, 대부분 DTO라는 명칭을 선호  

#### 5. 메소드 Overloading  
- overload : 하나의 메소드 이름을 사용하면서 여러 기능을 제공  
> 같은 역할은 같은 메소드 이름을 가져야 한다.  

#### 6. 메소드에서 값 넘겨주기  
- 리턴 문장 이후의 로직 존재 시 `unreachable statement` 컴파일 오류 발생  

#### 7. static 메소드와 일반 메소드의 차이  
- static이 아닌 변수 이름은 static  메소드에서 참조할 수 없다.  
- static 변수 선언시 클래스 변수가 된다.  
    - `조심!` 클래스 변수가 되면 모든 객체에서 하나의 값만 바라본다.  

#### 8. static 블록  
- 객체는 여러 개 생성하지만, 한번만 호출되어야 하는 코드가 있다면 `static 블록`을 사용하면 된다.  
- 클래스 내에 선언, 메소드 내에는 선언 불가  
```
static {
    // 딱 한번만 수행되는 코드
}
```

#### 9. Pass by value, Pass by reference  
- 모든 기본 자료형과 참조 자료형은 매개변수로 넘어갈 때, 값이 넘어가는 `Pass by value`  
- 참조 자료형 안에 있는 변수들은 매개변수로 넘어갈 때, 참조가 넘어가는 `Pass by reference`  

#### 10. 매개변수를 지정하는 특이한 방법  
- 임의 개수의 매개변수 : `타입... 변수명`  
- 이 방법은 하나의 메소드에서는 한 번만 사용가능하고, 여러 매개변수가 있다면 가장 `가장 마지막`에 선언해야 한다.  
```
public void testMethod(Object... params) {
    ...
}
```

<br>

### 9장. 자바를 배우면 패키지와 접근제어자는 꼭 알아야 해요.  

#### 1. 패키지는 그냥 폴더의 개념이 아니에요.  
- 패키지 네이밍 단 하나의 유의사항 : 이름을 java로 시작해서는 안 된다.  

#### 2. 패키지 이름은 이렇게 지어요.  
- 패키지 이름은 모두 소문자로. (권장사항)  
- 자바의 예약어를 사용하면 절대 안 된다.  

#### 3. import를 이용하여 다른 패키지에 접근하기  
- import.c.*  
    - "*" : 해당 패키지에 선언한 클래스만 import, 하위 패키지는 import 안 함  
- static 메소드나 변수가 중복일 경우  
    - 자신의 클래스에 있는 static 메소드, 변수 > import 하는 static 메소드, 변수  

#### 4. 자바의 접근제어자  
- Access Modifier  
    - public : 누구나  
    - protected : 같은 패키지 or 상속 관계  
    - package-private : 기본값, 같은 패키지  
    - private : 해당 클래스 내  
- 두레이에 간단하게 별도 정리  

#### 5. 클래스 접근 제어자 선언할 때의 유의점  
- public으로 선언된 클래스가 소스 내에 있다면, 해당 소스 파일의 이름은 public인 클래스와 동일해야 한다.  
<br>

### 10장. 자바는 상속이라는 것이 있어요.  

#### 1. 자바에서 상속이란?  
- public class Child `extends` Parent > extends : 자바 예약어, 확장하다.  
    - 부모 클래스에 선언되어 있는 public 및 protected 이용 가능  
- 자식 클래스의 생성자가 호출되면, 자동으로 부모 클래스의 기본 생성자가 호출된다.  
- 자바에서는 `다중 상속이 안 된다.` (extends 뒤 클래스 1개만 가능)  

#### 2. 상속과 생성자  
- 부모 클래스의 기본 생성자가 없으면 자식 클래스 사용 시 오류 발생  
    - 컴파일 시, 자식 클래스 생성자 내 super()가 자동으로 추가되기 때문  
- 해결 방안  
    - 방법 (1) 부모 클래스에 기본 생성자를 만든다.  
    - 방법 (2) 자식 클래스에서 `super()`를 사용해 부모 클래스의 생성자를 명시적으로 지정한다.  
- super()는 `반드시 생성자의 첫 줄`에 있어야 한다.  

#### 3. 메소드 Overriding  
- Overriding : 다른 무엇보다 더 중요한, 최우선시 되는  
- 자식 클래스에서 부모 클래스에 있는 메소드와 동일하게 선언하는 것  
    - <span style="color:#0052cc">**접근제어자, 리턴 타입, 메소드 이름, 매개변수 타입과 개수가 모두 동일해야 함 (동일한 시그니처)**</span>  
- 자식 클래스에서 접근제어자가 `더 확대되는 건 가능`하지만 축소는 문제가 된다.  

#### 4. 참조 자료형의 형변환  
- 자식 객체를 생성할 때, 부모 생성자를 사용하면 안 된다.  
```
Child child = new Parent()          X

Parent parent = new Child()         O
```
- 사용 가능한 데이터의 범위가 좁아질 경우, 명시적 형변환을 해야 한다.  
- instanceof : 타입 구분 예약어 > 객체 instanceof 타입  
```
public void testMethod(Child child) {
    System.out.println(child instanceof Parent);
}
```

- 가장 하위에 있는 자식 타입부터 검증할 것 (상속일 시 부모 타입으로도 true이므로)  

#### 5. Polymorphism(폴리모피즘) - 다형성  
- 부모 클래스로 형변환을 하더라도, 실제 호출되는 것은 생성자를 사용한 클래스에 있는 메소드가 호출된다.  

#### 6. 자식 클래스에서 할 수 있는 일들을 다시 정리해보자.  
- 부모 클래스에 선언된 동일한 이름을 가진 변수를 선언할수도 있지만, 이렇게 덮어쓰는 건 권장하지 않는다.  

<br>
* * *  

*출처 : 자바의 신 1 개정판 - 이상민 지음*
