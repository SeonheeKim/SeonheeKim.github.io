## Chapter 07. 주요 디자인 패턴  

### 1. 디자인 패턴이란?  
- 이전에 비슷한 상황에서 사용했던 설계를 재사용하는 경우가 종종 발생한다.  
  이렇게 반복적으로 사용되는 설계는 `클래스`, `객체의 구성`, `객체 간 메시지 흐름`에서 일정 패턴을 갖는다.  
- GoF(Gang of Four) 패턴 중에서 자주 사용되는 패턴을 소개  
    - 전략 패턴 / 템플릿 메서드 패턴 / 상태 패턴  
    - 데코레이터 패턴 / 프록시 패턴 / 어댑터 패턴  
    - 옵저버 패턴 / 미디에이터 패턴 / 파사드 패턴  
    - 추상 팩토리 패턴 / 컴포지트 패턴  
    - Null 객체 패턴 (not GoF 패턴)  
<br>

### 2. 전략(Strategy) 패턴  
- 특정 컨텍스트(Context)에서 알고리즘(기능, Strategy)를 별도로 분리하는 설계 방법  
- 예시 ) 그림 7.1  
![image_7.1](https://raw.githubusercontent.com/SeonheeKim/SeonheeKim.github.io/master/content/images/2021-01-12/image_7.1.png)  
- 인터페이스로 필요한 전략을 추상화, 각 콘크리트 클래스는 상황에 맞는 전략을 제공  
- 컨텍스트는 기능 자체의 책임을 갖고 있다.  
- 전략 패턴에서 컨텍스트는 사용할 전략을 직접 선택하지 않는다.  
    - `컨텍스트의 클라이언트`가 컨텍스트에 사용할 전략을 전달해준다. (DI 이용).  
    - 전략이 어떤 메서드를 제공할 지의 여부는 컨텍스트가 전략을 어떤 식으로 사용하느냐에 따라 다르다.  
<br>
- 컨텍스트를 사용하는 클라이언트가 전략의 상세 구현에 의존한다.  
- 예시 ) 그림 7.2  
![image_7.2](https://raw.githubusercontent.com/SeonheeKim/SeonheeKim.github.io/master/content/images/2021-01-12/image_7.2.png)  
- 상세 구현에 의존하는 부분이 문제처럼 보일 수 있으나, 전략의 콘크리트 클래스와 클라이언트 코드가 쌍을 이루기 때문에 코드 응집도를 높이고 유지 보수에 용이하다.  
<br>
- 전략 패턴의 이점 : 컨텍스트 코드의 변경 없이 새로운 전략을 추가하기 용이하다.  
  즉, 정책 확장에 열려 있고 변경에 닫혀있는 개방 폐쇄 원칙을 따르는 구조이다.   
<br>
- 적용처
    - 일반적으로 if-else으로 구성된 코드 블럭이 비슷한 기능을 수행하는 경우, 전략 패턴을 적용함으로써 코드를 확장 가능하도록 변경할 수 있다.  
    - 완전히 동일한 기능을 제공하지만, 성능의 장단점에 따라 알고리즘을 선택해야 하는 경우  
<br>

### 3. 템플릿 메서드(Template Method) 패턴  
- 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴  
- 구성  
    - 실행 과정을 구현한 상위 클래스  
    - 실행 과정의 일부 단계를 구현한 하위 클래스  
<br>
- 상위 클래스는 실행 과정을 구현한 메서드(템플릿 메서드)를 제공.  
  기능을 구현하는데 필요한 각 단계를 정의하며, 이 중 일부는 추상 메서드를 호출하는 방식으로 구현된다.  
- 템플릿 메서드를 상속 받은 하위 클래스는 호출하는 메서드만 알맞게 재정의하면 된다.  
<br>
- 장점 : 코드 중복을 방지하고 코드 재사용성을 높인다.  
- 특징 : 상위 클래스에서 흐름 제어를 한다. (일반적으로 하위 클래스에서 흐름 제어를 함)  
<br>
- 템플릿 메서드의 경우 외부에 제공하는 기능에 해당되기 때문에 public 범위를 가진다.  
- 하위 클래스에서 사용하는 추상 메서드는 템플릿 메서드에서만 호출되고, 하위 클래스에서 재정의되므로 protected 범위를 가진다.  
<br>
- 추상 메서드로 정의되어 하위 클래스에서 재정의 되는 메서드는 `기능의 확장 지점`으로 사용될 수 있다.  
- 훅(Hook) 메서드라고도 부른다.  
<br>

#### 3.2 템플릿 메서드와 전략 패턴의 조합  
*해당 부분은 전략 패턴에 가깝다. GoF 패턴에서 템플릿 메서드 패턴은 상속에 기반한 패턴으로 정의하고 있으므로, 해당 내용은 템플릿 메서드 패턴의 변형으로 생각하길 바란다.*  

- 템플릿 메서드와 전략 패턴을 함께 사용하면 상속이 아닌 `조립`의 방식으로 템플릿 메서드 패턴을 활용할 수 있다.  
- 대표적 예시 ) 스프링 프레임워크의 Template로 끝나는 클래스들  
<br>
- 변경되는 부분(템플릿 메서드 패턴의 훅 메서드 부분)을 실행할 객체를 파라미터로 전달받는 방식으로 구현됨  
<br>


|  | 상속 구현 | 조립/위임 구현 |
| --- | --- | --- |
| 장점 | 훅 메서드를 재정의하는 방법으로, 하위 클래스에서 쉽게 확장 기능 제공이 가능 | 런타임에 템플릿 메서드에서 사용할 객체를 교체 가능 |
| 단점 | 클래스가 불필요하게 증가할 수 있다. 런타임에 교체 불가 | 확장 기능을 제공하려면 구현이 복잡해질 수 있음 |

<br>

### 4. 상태(State) 패턴  
- 기능이 상태에 따라 다르게 동작해야 할 때 사용 가능한 패턴  
- 상태들을 별도 타입으로 분리하여, 각 상태별로 알맞은 하위 타입을 구현  

<br>
- 예시) 그림 7.7  

![image_7.7](https://raw.githubusercontent.com/SeonheeKim/SeonheeKim.github.io/master/content/images/2021-01-12/image_7.7.png)  
<br>
- 상태 객체가 기능을 제공한다.  
- 컨텍스트는 상태 객체에 처리를 위임한다.  
<br>

- 상태 패턴의 장점  
    - 새로운 상태가 추가되더라도 컨텍스트 코드가 받는 영향이 최소화된다.  
    - 동작이 상태별로 구분되기 때문에, 상태별 동작을 수정하기가 쉽다.  
<br>

#### 4.1 상태 변경은 누가?  
- 상태 변경은 상태 패턴 적용 시 고려할 문제 > 컨텍스트의 상태 변경을 누가 하는가?  
    - 컨텍스트  
    - 상태 객체  
<br>

|  | 컨텍스트 | 상태 객체 |
| --- | --- | --- |
| 장점 | - 비교적 상태 개수가 적다. <br> - 상태 변경 규칙이 거의 바뀌지 않는다. <br> (상태 변경 처리 코드가 단순함 > 상태 변경 유연성 증가) <br> - 상태 객체가 자신이 수행해야 하는 작업만 처리한다. | - 컨텍스트에 영향을 주지 않으면서 상태를 추가/상태 변경 규칙을 변경할 수 있다. |
| 단점 | - 컨텍스트 코드가 다소 복잡해질 수 있다. | - 상태 변경 규칙이 여러 클래스에 분산되어 있기 때문에, 상태 변경 규칙을 파악하기 어렵다. <br> - 한 상태 클래스에서 다른 상태 클래스에 대한 의존도 발생 <br> - 컨텍스트의 다른 값에 접근해야 할 경우, 이를 위해 인터페이스에 메서드 추가 필요 |

<br>  
* * *  

*출처 : 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 - 최범균 지음*